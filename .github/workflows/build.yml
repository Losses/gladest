name: Build

on:
  workflow_call:
    inputs:
      ref:
        description: "The branch, tag, or SHA to check out"
        required: true
        type: string
      update-version:
        description: "Update version before building?"
        required: false
        type: boolean
        default: false
      version:
        description: "Version update type (ignored if update-version is false)"
        required: false
        type: string
        default: "patch" # e.g., patch, minor, major, or specific version
      github-release:
        description: "Publish GitHub release?"
        required: false
        type: boolean
        default: false
      tag:
        description: "The release tag (ignored if github-release is false)"
        required: false
        type: string
        default: ""

jobs:
  matrix:
    name: Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.result }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
          # fetch-depth: 0 # Potentially needed if neon show ci uses git history, uncomment if necessary

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      # Setup Neon Environment - This uses a local action relative to the repo root.
      # It should NOT have a working-directory set here.
      - name: Setup Neon Environment (Rust/Cross)
        uses: ./.github/actions/setup
        with:
          use-cross: ${{ matrix.cfg.script == 'cross' }}
          platform: ${{ matrix.cfg.platform }}

      # Run subsequent steps within the package directory
      - name: Install Dependencies
        working-directory: ./markdown-it-gladest
        run: bun install --frozen-lockfile

      - name: Look Up Matrix Data
        id: matrixData
        working-directory: ./markdown-it-gladest
        shell: bash
        run: echo "json=$(bunx neon show ci github | jq -rc)" | tee -a $GITHUB_OUTPUT

      # Compute Matrix doesn't directly interact with files, uses previous step output.
      # No working-directory needed here.
      - name: Compute Matrix
        id: matrix
        uses: actions/github-script@v7
        with:
          script: |
            const platforms = ${{ steps.matrixData.outputs.json }};
            const matrix = [];
            if (platforms.macOS) {
              matrix.push(...platforms.macOS.map(platform => ({ os: "macos-latest", platform, script: "build" })));
            }
            if (platforms.Windows) {
              matrix.push(...platforms.Windows.map(platform => ({ os: "windows-latest", platform, script: "build" })));
            }
            if (platforms.Linux) {
              matrix.push(...platforms.Linux.map(platform => ({ os: "ubuntu-latest", platform, script: "cross" })));
            }
            console.log("Computed Matrix:", matrix);
            return matrix;

  binaries:
    name: Binaries (${{ matrix.cfg.platform }})
    needs: [matrix]
    if: ${{ needs.matrix.outputs.matrix != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        cfg: ${{ fromJSON(needs.matrix.outputs.matrix) }}
    runs-on: ${{ matrix.cfg.os }}
    permissions:
      contents: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
          fetch-depth: 0 # Needed for version bumping

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install OpenSSL (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install openssl@3 pkg-config
          # Set environment variables for openssl-sys crate to find Homebrew's OpenSSL
          echo "OPENSSL_ROOT_DIR=$(brew --prefix openssl@3)" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=$(brew --prefix openssl@3)/lib" >> $GITHUB_ENV
          # Also add pkg-config path
          echo "PKG_CONFIG_PATH=$(brew --prefix openssl@3)/lib/pkgconfig:$(brew --prefix libffi)/lib/pkgconfig" >> $GITHUB_ENV


      - name: Install OpenSSL (Windows)
        if: runner.os == 'Windows'
        run: |
          # vcpkg is usually pre-installed on GitHub Windows runners
          # Ensure VCPKG_ROOT is set (usually automatic) and vcpkg is in PATH
          echo "Installing OpenSSL via vcpkg..."
          vcpkg install openssl:${{ matrix.cfg.platform == 'win32-x64-msvc' && 'x64' || 'x86' }}-windows-static-md
          # openssl-sys should auto-detect vcpkg installations if VCPKG_INSTALLATION_ROOT is set.
          # If issues persist, uncomment and adapt the following:
          # $VCPKG_INSTALL_DIR = Join-Path $env:VCPKG_INSTALLATION_ROOT "installed/${{ matrix.cfg.platform == 'win32-x64-msvc' && 'x64' || 'x86' }}-windows-static-md"
          # echo "OPENSSL_DIR=$VCPKG_INSTALL_DIR" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          # echo "OPENSSL_STATIC=1" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append # If using static-md
        shell: pwsh # Use PowerShell for Windows steps

      # Setup Neon Environment - Uses local action relative to repo root.
      - name: Setup Neon Environment (Rust/Cross)
        id: neon
        uses: ./.github/actions/setup
        with:
          use-cross: ${{ matrix.cfg.script == 'cross' }}
          platform: ${{ matrix.cfg.platform }}

      # Run subsequent steps within the package directory
      - name: Install Dependencies
        working-directory: ./markdown-it-gladest
        run: bun install --frozen-lockfile

      - name: Build Binary
        working-directory: ./markdown-it-gladest
        shell: bash
        env:
          CARGO_BUILD_TARGET: ${{ steps.neon.outputs.target }}
          NEON_BUILD_PLATFORM: ${{ matrix.cfg.platform }}
        run: bun run ${{ matrix.cfg.script }}

      - name: Pack Platform Binary
        id: pack
        working-directory: ./markdown-it-gladest
        shell: bash
        run: |
          echo "*** Debug: Start of Pack Platform Binary"
          echo "Initial PWD: $(pwd)"

          # Define REPO ROOT dist directory (absolute path)
          REPO_DIST_DIR="${GITHUB_WORKSPACE}/dist"
          echo "Target REPO DIST directory (absolute): ${REPO_DIST_DIR}"

          # Create dist directory at the REPO ROOT if it doesn't exist
          mkdir -p "${REPO_DIST_DIR}"
          echo "Listing REPO_ROOT (${GITHUB_WORKSPACE}) contents after mkdir:"
          ls -la "${GITHUB_WORKSPACE}"

          # Platform specific directory relative to current PWD
          PLATFORM_SUBDIR="./platforms/${{ matrix.cfg.platform }}"
          echo "Platform subdirectory: ${PLATFORM_SUBDIR}"

          # Define the output directory relative to the *current* PWD (markdown-it-gladest) for the pack command if needed
          # However, bun pm pack in later versions might support absolute paths better. Let's try absolute first.
          # BUN_OUTDIR="${REPO_DIST_DIR}" # Try absolute path

          # *** If bun pm pack requires relative path from CWD:
          # Change directory *temporarily* for packing if needed, OR calculate relative path
          # Relative path from here (markdown-it-gladest) to REPO_DIST_DIR is "../dist"
          BUN_OUTDIR="../dist"
          echo "Using relative outdir for bun: ${BUN_OUTDIR}"
          # *** End Relative Path Calculation

          # Navigate to the directory containing the package.json specific to the platform binary
          # Assuming the platform directory itself is the package to be packed
          echo "Changing directory to platform subdirectory: ${PLATFORM_SUBDIR}"
          cd "${PLATFORM_SUBDIR}"
          echo "Current PWD after cd: $(pwd)"
          ls -la # Show contents of platform dir before packing

          # Define relative path from *this new PWD* to the REPO_DIST_DIR
          # From markdown-it-gladest/platforms/<platform> to REPO_ROOT/dist is ../../../dist
          BUN_OUTDIR_FROM_PLATFORM_DIR="../../../dist"
          echo "Packing from $(pwd) with relative outdir: ${BUN_OUTDIR_FROM_PLATFORM_DIR}"

          # Pack and output to the REPO ROOT dist directory
          echo "Executing: bun pm pack --destination ${BUN_OUTDIR_FROM_PLATFORM_DIR}"
          # Capture potentially multi-line output, get the line ending in .tgz
          PACK_OUTPUT_ABSPATH=$(bun pm pack --destination "${BUN_OUTDIR_FROM_PLATFORM_DIR}" | grep '\.tgz$' | head -n 1)
          echo "bun pm pack absolute path output: ${PACK_OUTPUT_ABSPATH}"

          # Error check: Did we get an absolute path?
          if [[ -z "$PACK_OUTPUT_ABSPATH" ]]; then
            echo "::error::Failed to capture packed filename path from bun output."
            echo "Listing target directory (${BUN_OUTDIR_FROM_PLATFORM_DIR}) contents:"
            ls -l "${BUN_OUTDIR_FROM_PLATFORM_DIR}" || echo "Target directory listing failed."
            exit 1
          fi

          # Extract just the filename using basename
          FILENAME=$(basename "$PACK_OUTPUT_ABSPATH")
          echo "Captured filename: ${FILENAME}"
          echo "filename=${FILENAME}" | tee -a $GITHUB_OUTPUT

          # Verification (Optional but recommended)
          # Verify the file exists at the *correct absolute path*
          PACKED_FILE_ABS_PATH="${REPO_DIST_DIR}/${FILENAME}"
          echo "Verifying packed file at absolute path: ${PACKED_FILE_ABS_PATH}"

          if [[ -f "${PACKED_FILE_ABS_PATH}" ]]; then
             echo "Packed file ${FILENAME} successfully found in target directory (${REPO_DIST_DIR})."
             echo "Listing contents of target directory (${REPO_DIST_DIR}):"
             ls -l "${REPO_DIST_DIR}"
          else
             echo "::warning::Packed file ${FILENAME} NOT found at ${PACKED_FILE_ABS_PATH}."
             echo "Listing target directory contents (${REPO_DIST_DIR}):"
             ls -l "${REPO_DIST_DIR}" || echo "Target directory listing failed."
             # Also list where we ran pack from, just in case
             echo "Listing current directory ($(pwd)) contents:"
             ls -l
             exit 1 # Fail the step if verification fails
          fi

          echo "*** Debug: End of Pack Platform Binary"

      # Release Asset step runs at the root level, needs path relative to root
      - name: Release Asset
        if: ${{ inputs.github-release && inputs.tag != '' }}
        uses: softprops/action-gh-release@v2.0.4
        with:
          # Path is relative to the REPO ROOT where the dist dir was created
          files: ./dist/${{ steps.pack.outputs.filename }}
          tag_name: ${{ inputs.tag }}

  main:
    name: Main Package
    needs: [matrix] # Changed from binaries to matrix, as it doesn't depend on binary artifacts
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
          # If the main package needs the bumped version, you might need fetch-depth: 0
          # and potentially check out *after* the version bump commit is available (complex).
          # Assuming for now it uses the version from the initially checked out ref.

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      # No Neon setup needed here based on the original workflow

      # Run subsequent steps within the package directory
      - name: Install Dependencies
        working-directory: ./markdown-it-gladest
        run: bun install --frozen-lockfile

      - name: Pack Main Package
        id: pack
        working-directory: ./markdown-it-gladest
        shell: bash
        run: |
          # Create dist directory at the REPO ROOT
          mkdir -p ../dist
          # Pack and output to the REPO ROOT dist directory
          FILENAME=$(bun pm pack --destination ../dist | grep '\.tgz$') # Adjust output path relative to working dir
          echo "filename=${FILENAME}" | tee -a $GITHUB_OUTPUT
          echo "Packed file: ../dist/${FILENAME}" # Log the correct path
          ls -l ../dist # List contents of the root dist directory

      # Release Asset step runs at the root level, needs path relative to root
      - name: Release Main Package Asset
        if: ${{ inputs.github-release && inputs.tag != '' }}
        uses: softprops/action-gh-release@v2.0.4
        with:
          # Path is relative to the REPO ROOT where the dist dir was created
          files: ./dist/${{ steps.pack.outputs.filename }}
          tag_name: ${{ inputs.tag }}